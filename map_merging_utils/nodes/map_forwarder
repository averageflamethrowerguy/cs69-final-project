#!/usr/bin/env python
# The line above is important so that this file is interpreted with Python when running it.
# merge forwarder, written by Elliot Potter
# Nov 2022

# Import of python modules.
import math  # use of pi.
import tf  # library for transformations
import rospy  # module for ROS APIs
from std_msgs.msg import String
import json
from nav_msgs.msg import OccupancyGrid  # Message type for map data

# Format: /robot_0/map
OCCUPANCY_GRID_IN_TOPIC = "/map"
# Format: /robot_0/updated_map
OCCUPANCY_GRID_UPDATED_TOPIC = "/updated_map"
# Format: /robot_0/robot_0/current_map -- the first robot_0 is the namespace doing the updating, second is the namespace
# to update
OCCUPANCY_GRID_OUT_TOPIC = "/current_map"


class MapForwarder:
    def __init__(self, robot_name):
        self.robot_name = robot_name

        self.current_header = None
        self.current_grid = None
        self.current_metadata = None
        self.different_from_gmapping = False  # set this to True when we receive a message on /updated_map
        self.finished_init = False

        # set up publishers and subscribers
        print("/" + robot_name + OCCUPANCY_GRID_IN_TOPIC)
        self.gmapping_sub = rospy.Subscriber("/" + robot_name + OCCUPANCY_GRID_IN_TOPIC, OccupancyGrid,
                                             self.gmapping_callback)
        self.updates_sub = rospy.Subscriber("/" + robot_name + OCCUPANCY_GRID_UPDATED_TOPIC, OccupancyGrid,
                                            self.updated_callback)
        self.current_pub = rospy.Publisher("/" + robot_name + "/" + robot_name + OCCUPANCY_GRID_OUT_TOPIC,
                                           OccupancyGrid, queue_size=1)

        rospy.sleep(0.5)
        self.finished_init = True
        print("MAP_FORWARDER: finished initialization")

    def gmapping_callback(self, msg):
        """
        We receive a new occupancy grid on the gmapping topic: we want to merge it with the current grid

        We assume the two maps have the same origin and resolution.
        """
        print("GMAPPING_CALLBACK: hit gmapping callback")

        if not self.finished_init:
            rospy.sleep(0.5)

        if not self.different_from_gmapping:
            self.current_header = msg.header
            self.current_grid = msg.data
            self.current_metadata = msg.info
        else:
            new_header = self.current_header
            new_metadata = self.current_grid
            new_grid = self.current_metadata

            # if the new data explores unexplored space, edit those cells in the current matrix
            for row_id in range(msg.info.height):
                for col_id in range(msg.info.width):
                    y_loc = row_id * msg.info.resolution + msg.info.origin.position.y
                    x_loc = row_id * msg.info.resolution + msg.info.origin.position.x

                    new_row = (y_loc - new_metadata.origin.position.y) / new_metadata.resolution
                    new_col = (x_loc - new_metadata.origin.position.x) / new_metadata.resolution

                    if (new_grid[new_row * new_metadata.info.width + new_col] == -1 and
                            msg.data[row_id * msg.info.width + col_id] != -1
                    ):
                        new_grid[new_row * new_metadata.info.width + new_col] = msg.data[
                            row_id * msg.info.width + col_id]

            self.current_header = new_header
            self.current_grid = new_grid
            self.current_metadata = new_metadata

        # publish the current grid
        grid = OccupancyGrid()
        grid.header = self.current_header
        grid.info = self.current_metadata
        grid.data = self.current_grid
        print("GMAPPING_CALLBACK: Publishing...!")
        self.current_pub.publish(grid)

    def updated_callback(self, msg):
        """This is the most up-to-date map, which overrides the other grid / metadata stuff we have loaded"""
        print("UPDATED_CALLBACK: Received updated data!")

        self.different_from_gmapping = True
        if (msg.info.origin.position.x != self.current_metadata.origin.position.x or
                msg.info.origin.position.y != self.current_metadata.origin.position.y or
                msg.info.origin.position.z != self.current_metadata.origin.position.z
        ):
            print("UPDATED_CALLBACK: Origin mismatch!")
            # NOTE -- this is NOT general, but multirobot_map_merge seems to give origin=0 results, which are fine
            # if we just exchange the position of one for the other
            # print(msg.info)
            # print(self.current_metadata)
            # TODO -- neither map starts centered!

            msg.info.origin.position.x = self.current_metadata.origin.position.x - 0.5*(msg.info.width - self.current_metadata.width) * msg.info.resolution
            msg.info.origin.position.y = self.current_metadata.origin.position.y - 0.5*(msg.info.height - self.current_metadata.height) * msg.info.resolution
            self.current_metadata = msg.info
            self.current_grid = msg.data
        else:
            self.current_grid = msg.data
            self.current_metadata = msg.info

        # publish the current grid
        grid = OccupancyGrid()
        grid.header = self.current_header
        grid.info = self.current_metadata
        grid.data = self.current_grid
        print("UPDATED_CALLBACK: Publishing...!")
        self.current_pub.publish(grid)


if __name__ == "__main__":
    rospy.init_node('map_forwarder')
    rospy.sleep(1)
    print("MAP_FORWARDER: starting up")
    robot_name = rospy.get_param("robot_name")
    handler = MapForwarder(robot_name)
    rospy.spin()
