#!/usr/bin/env python
#The line above is important so that this file is interpreted with Python when running it.

# Import of python modules.
import math # use of pi.

# import of relevant libraries.
import rospy # module for ROS APIs
from geometry_msgs.msg import Twist # message type for cmd_vel
from sensor_msgs.msg import LaserScan # message type for scan
from nav_msgs.msg import Odometry # message for odometry (robot position)
from tf.transformations import euler_from_quaternion

# Constants.
FREQUENCY = 10 #Hz.
LINEAR_VELOCITY = 0.15 # m/s
ANGULAR_VELOCITY = math.pi/4 # rad/s
LASER_ANGLE_FRONT = 0 # radians
MIN_THRESHOLD_DISTANCE = 0.6 # m, threshold distance.
DEFAULT_CMD_VEL_TOPIC = 'cmd_vel'
DEFAULT_SCAN_TOPIC = 'scan'
DEFAULT_GLOBAL_ODOM_TOPIC = '/global_odom'
DEFAULT_LOCAL_ODOM_TOPIC = 'odom'

class OtherRobotPos:
    def __init__(self, starting_x, starting_y, heading):
        """Constructor."""
        self.x = starting_x
        self.y = starting_y
        self.heading = heading

class SimpleFlocking():
    def __init__(self, linear_velocity=LINEAR_VELOCITY, angular_velocity=ANGULAR_VELOCITY):
        """Constructor."""
        # Getting params from launch file
        self.neighborhood_distance = rospy.get_param("/neighborhood_distance") 
        self.separation_boundary_dist = rospy.get_param("/separation_boundary_dist") 
        self.cohesion_weight = rospy.get_param("/cohesion_weight") 
        self.alignment_weight = rospy.get_param("/alignment_weight") 
        self.separation_weight = rospy.get_param("/separation_weight") 
        self.num_other_robots = rospy.get_param("/num_robots") - 1

        # Setting up publishers/subscribers.
        self._cmd_pub = rospy.Publisher(DEFAULT_CMD_VEL_TOPIC, Twist, queue_size=1)
        self._global_odom_pub = rospy.Publisher(DEFAULT_GLOBAL_ODOM_TOPIC, Odometry, queue_size=1)

        # Setting up subscriber.
        self._laser_sub = rospy.Subscriber(DEFAULT_SCAN_TOPIC, LaserScan, self._laser_callback, queue_size=1)
        self._local_odom_sub = rospy.Subscriber(DEFAULT_LOCAL_ODOM_TOPIC, Odometry, self._local_odom_callback, queue_size=1)
        self._global_odom_sub = rospy.Subscriber(DEFAULT_GLOBAL_ODOM_TOPIC, Odometry, self._global_odom_callback, queue_size=1)

        # Other variables.
        self.linear_velocity = linear_velocity # Constant linear velocity set.
        self.angular_velocity = angular_velocity # Constant angular velocity set.
        self._close_obstacle = False # Flag variable that is true if there is a close obstacle.
        self._in_avoiding_state = False
        self._odom_x = 0
        self._odom_y = 0
        self._heading = 0

        # Identifying information
        self._my_name = rospy.get_namespace()[1:]
        self.neighbors = {}

        # Movement info
        self._forward_vel = 0
        self._angular_vel = 0
        
    def rotate_in_place(self, rotation_angle):
        """
        Rotate in place the robot of rotation_angle (rad) based on fixed velocity.
        Assumption: Counterclockwise rotation.
        """
        twist_msg = Twist()
        twist_msg.angular.z = self.angular_velocity
        
        duration = rotation_angle / twist_msg.angular.z
        start_time = rospy.get_rostime()
        rate = rospy.Rate(FREQUENCY)
        while not rospy.is_shutdown():
            # Check if done
            if rospy.get_rostime() - start_time >= rospy.Duration(duration):
                break
                
            # Publish message.
            self._cmd_pub.publish(twist_msg)
            
            # Sleep to keep the set frequency.
            rate.sleep()

        # Rotated the required angle, stop.
        self.stop()
    
    def move_forward(self, distance):
        """Function to move_forward for a given distance."""
        # Rate at which to operate the while loop.
        rate = rospy.Rate(FREQUENCY)

        # Setting velocities. 
        twist_msg = Twist()
        twist_msg.linear.x = self.linear_velocity
        start_time = rospy.get_rostime()
        duration = rospy.Duration(distance/twist_msg.linear.x)

           # Loop.
        while not rospy.is_shutdown():
            # Check if traveled of given distance based on time.
            if rospy.get_rostime() - start_time >= duration:
                break

            # Publish message.
            if self._close_obstacle:
                self.stop()
            else:
                self._cmd_pub.publish(twist_msg)

            # Sleep to keep the set publishing frequency.
            rate.sleep()

        # Traveled the required distance, stop.
        self.stop()
    
    def stop(self):
        """Stop the robot."""
        twist_msg = Twist()
        self._cmd_pub.publish(twist_msg)

    def _laser_callback(self, msg):
        """Processing of laser message."""
        # Access to the index of the measurement in front of the robot.
        # NOTE: assumption: the one at angle 0 corresponds to the front.
        i = int((LASER_ANGLE_FRONT - msg.angle_min) / msg.angle_increment)
        if msg.ranges[i] <= MIN_THRESHOLD_DISTANCE:
            self._close_obstacle = True
            self._in_avoiding_state = True
        else:
            self._close_obstacle = False
    

    def _local_odom_callback(self, msg):
        """Callback function for reading robot position from the odometer."""
        # Get position from message
        self._odom_x = msg.pose.pose.position.x
        self._odom_y = msg.pose.pose.position.y

        # Get heading of current robot
        self._heading = self.heading_from_odom(msg)
        self._global_odom_pub.publish(msg)
    
    def _global_odom_callback(self, msg):
        """Add (relative) positions of other robots to `neighbors` map."""
        robot_name = msg._connection_header["callerid"]
        if self._my_name not in robot_name:
            self.neighbors[robot_name] = OtherRobotPos(starting_x = msg.pose.pose.position.x, starting_y = msg.pose.pose.position.y, heading = self.heading_from_odom(msg))
    
    def calc_cohesion(self):
        """Calculate `cohesion` force between robot and other robots."""
        # Get average position of all other robots in neighborhood (centroid)
        centroid_x, centroid_y = self.calc_centroid()

        # Get vector between current pos and centroid
        vect_x, vect_y = self.calc_difference_vect(centroid_x, centroid_y)

        return self.calc_angular_velocity(vect_x, vect_y)
        
    
    def calc_separation(self):
        """Calculate `separation` force between robot and other robots."""
        # Create vector representing weighted average relative location of too-close robots
        vect_x = 0
        vect_y = 0

        # Find weighted average vector of too-close robots
        for robot in self.neighbors:
            robot_obj = self.neighbors[robot]
            distance_to_robot = self.get_distance(self._odom_x, self._odom_y, robot_obj.x, robot_obj.y)
            if(distance_to_robot <= self.separation_boundary_dist):
                # Find and reverse vector to other robot (scaled inversely by distance to robot)
                vect_x -= (robot_obj.x - self._odom_x) / distance_to_robot
                vect_y -= (robot_obj.y - self._odom_y) / distance_to_robot

        return self.calc_angular_velocity(vect_x, vect_y)
    
    def calc_alignment(self):
        """Get average alignment of all other robots to find out what this robot's heading needs to be."""
        avg_heading = 0
        for robot in self.neighbors:
            current_robot = self.neighbors[robot]
            if(self.is_neighbor(current_robot)):
                avg_heading += self.neighbors[robot].heading - self._heading
        avg_heading /= len(self.neighbors)

        # Divide by some constant (PI) to prevent steering too fast
        avg_heading /= math.pi

        # Multiply by max angular speed
        return avg_heading * ANGULAR_VELOCITY
    
    def final_flocking_movement(self):
        """Implement final flocking behavior and send cmd_vel command to robot."""
        if(len(self.neighbors) >= self.num_other_robots):
            if not self._in_avoiding_state:
                twist_msg = Twist()
                twist_msg.linear.x = LINEAR_VELOCITY
                
                angular_velocity = ((self.separation_weight * self.calc_separation()) + (self.alignment_weight * self.calc_alignment()) + (self.cohesion_weight * self.calc_cohesion()))

                twist_msg.angular.z = angular_velocity
                self._cmd_pub.publish(twist_msg)
            else:
                # If robot is about to collide with an obstacle, turn and move robot away from obstacle
                self.rotate_in_place(math.pi)
                self.move_forward(2)
                self._in_avoiding_state = False

    def heading_from_odom(self, msg):
        roll_heading, pitch_heading, yaw_heading = euler_from_quaternion([msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w])
        return yaw_heading
    
    def calc_centroid(self):
        """Calcuate the centroid of all robots in the `neighborhood` of the current robot."""
        avg_x = 0
        avg_y = 0
        num_neighbors = 0
        for robot in self.neighbors:
            curr_robot = self.neighbors[robot]
            if(self.is_neighbor(curr_robot)):
                num_neighbors += 1
                avg_x += curr_robot.x
                avg_y += curr_robot.y
        
        # Check that there is at least one neighbor to prevent divide by 0 error
        if(num_neighbors == 0):
            return self._odom_x, self._odom_y
        
        # Average vector components to get centroid
        avg_x /= num_neighbors
        avg_y /= num_neighbors

        return avg_x, avg_y
    
    def calc_difference_vect(self, centroid_x, centroid_y):
        """Calculate the difference between two vectors."""
        vect_x = centroid_x - self._odom_x
        vect_y = centroid_y - self._odom_y
        return vect_x, vect_y
    
    def get_distance(self, x_1, y_1, x_2, y_2):
        """Calculate the euclidean distance between two vectors/points."""
        return ((x_1 - x_2) ** 2) + ((y_1 - y_2) ** 2)

    def is_neighbor(self, other_robot):
        """Determine if another robot is in the `neighborhood` of the current robot."""
        return self.get_distance(other_robot.x, other_robot.y, self._odom_x, self._odom_y) <= self.neighborhood_distance

    def calc_angular_velocity(self, vect_x, vect_y):
        """Calculate the angular velocity associated with a vector."""
        # Get angle from vector (assumed to be in robot refernce frame with robot as <0,0>)
        theta_total = math.atan2(vect_y, vect_x)

        # If we have a negative angle, add 2*PI to get desired angle
        if(theta_total < 0):
            theta_total += (2 * math.pi)
        
        # Subtract current heading from ideal heading to get difference (angle needed to turn towards ideal heading)
        theta_diff = theta_total - self._heading

        # If difference angle is greater than PI, subtract 2PI to get clockwise (negative) equivalent
        if theta_diff > math.pi:
            theta_diff -= (2 * math.pi)
        
        # Divide by some constant (PI) to prevent steering too fast
        theta_diff /= math.pi

        # Multiply by max angular speed
        angular_vel = theta_diff * ANGULAR_VELOCITY

        return angular_vel
def main():
    """Main function."""

    # 1st. initialization of node.
    rospy.init_node("simple_flocking")

    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the simple motion.
    simple_flocking = SimpleFlocking()

    # If interrupted, send a stop command.
    rospy.on_shutdown(simple_flocking.stop)

    # Robot moves 1 m forward, rotate of 180 degrees, and moves 1 m forward.
    try:
        while not rospy.is_shutdown():
            rate = rospy.Rate(FREQUENCY)
            simple_flocking.final_flocking_movement()
            rate.sleep()
    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")


if __name__ == "__main__":
    """Run the main function."""
    main()
